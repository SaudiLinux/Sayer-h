#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
وحدة فحص الثغرات الأمنية لبرنامج Sayer
"""

import requests
import concurrent.futures
import re
import json
from urllib.parse import urljoin, urlparse
from bs4 import BeautifulSoup
from tqdm import tqdm

from .utils import normalize_url, get_random_user_agent, is_valid_url


class VulnerabilityScanner:
    """فئة فحص الثغرات الأمنية"""
    
    def __init__(self, target, threads=5, timeout=30, logger=None):
        """تهيئة الفئة"""
        self.target = normalize_url(target) if is_valid_url(target) else f"http://{target}"
        self.threads = threads
        self.timeout = timeout
        self.logger = logger
        self.results = {}
        
        # قائمة الثغرات للفحص
        self.vulnerabilities = {
            "xss": self._check_xss,
            "sqli": self._check_sqli,
            "lfi": self._check_lfi,
            "rfi": self._check_rfi,
            "open_redirect": self._check_open_redirect,
            "csrf": self._check_csrf,
            "clickjacking": self._check_clickjacking,
            "cors": self._check_cors,
            "ssl_tls": self._check_ssl_tls,
            "cve": self._check_common_cve
        }
    
    def scan(self):
        """تنفيذ عملية فحص الثغرات"""
        if self.logger:
            self.logger.info(f"[+] بدء فحص الثغرات للهدف: {self.target}")
        
        # جمع المعلومات الأساسية عن الهدف
        self._gather_target_info()
        
        # فحص الثغرات المختلفة
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.threads) as executor:
            future_to_vuln = {executor.submit(vuln_check): vuln_name for vuln_name, vuln_check in self.vulnerabilities.items()}
            
            for future in tqdm(concurrent.futures.as_completed(future_to_vuln), 
                              total=len(future_to_vuln), 
                              desc="فحص الثغرات", 
                              disable=self.logger is None):
                vuln_name = future_to_vuln[future]
                try:
                    self.results[vuln_name] = future.result()
                except Exception as e:
                    if self.logger:
                        self.logger.error(f"[!] خطأ في فحص ثغرة {vuln_name}: {str(e)}")
                    self.results[vuln_name] = {"error": str(e)}
        
        # تقييم مستوى الخطورة الإجمالي
        self.results["risk_assessment"] = self._assess_risk()
        
        return self.results
    
    def _gather_target_info(self):
        """جمع المعلومات الأساسية عن الهدف"""
        try:
            headers = {"User-Agent": get_random_user_agent()}
            response = requests.get(self.target, headers=headers, timeout=self.timeout, allow_redirects=True)
            
            self.target_info = {
                "url": self.target,
                "status_code": response.status_code,
                "server": response.headers.get("Server", "Unknown"),
                "technologies": [],
                "forms": []
            }
            
            # استخراج التقنيات المستخدمة
            if "X-Powered-By" in response.headers:
                self.target_info["technologies"].append(response.headers["X-Powered-By"])
            
            # تحليل محتوى HTML
            if "text/html" in response.headers.get("Content-Type", ""):
                soup = BeautifulSoup(response.text, "html.parser")
                
                # استخراج النماذج
                for form in soup.find_all("form"):
                    form_data = {
                        "action": urljoin(self.target, form.get("action", "")),
                        "method": form.get("method", "get").upper(),
                        "inputs": []
                    }
                    
                    for input_tag in form.find_all(["input", "textarea", "select"]):
                        input_type = input_tag.get("type", "text")
                        input_name = input_tag.get("name", "")
                        
                        if input_name and input_type not in ["submit", "button", "reset", "image"]:
                            form_data["inputs"].append({
                                "name": input_name,
                                "type": input_type
                            })
                    
                    if form_data["inputs"]:
                        self.target_info["forms"].append(form_data)
                
                # البحث عن مؤشرات التقنيات المستخدمة
                tech_patterns = {
                    "WordPress": ["wp-content", "wp-includes", "wp-admin"],
                    "Joomla": ["joomla", "com_content", "com_users"],
                    "Drupal": ["drupal", "sites/all", "sites/default"],
                    "Laravel": ["laravel", "csrf-token", "_token"],
                    "Django": ["csrfmiddlewaretoken", "django"],
                    "React": ["react", "reactjs", "react-dom"],
                    "Angular": ["ng-", "angular", "ng-app"],
                    "Vue": ["vue", "v-", "vue.js"],
                    "Bootstrap": ["bootstrap", "navbar-", "container-fluid"],
                    "jQuery": ["jquery", "$(", "$."]
                }
                
                for tech, patterns in tech_patterns.items():
                    for pattern in patterns:
                        if pattern in response.text:
                            if tech not in self.target_info["technologies"]:
                                self.target_info["technologies"].append(tech)
                            break
            
            self.results["target_info"] = self.target_info
        
        except Exception as e:
            if self.logger:
                self.logger.error(f"[!] خطأ في جمع معلومات الهدف: {str(e)}")
            self.target_info = {"url": self.target, "error": str(e)}
            self.results["target_info"] = self.target_info
    
    def _check_xss(self):
        """فحص ثغرات Cross-Site Scripting (XSS)"""
        xss_results = {
            "name": "Cross-Site Scripting (XSS)",
            "description": "ثغرة تسمح للمهاجمين بحقن أكواد JavaScript ضارة في صفحات الويب",
            "severity": "High",
            "vulnerabilities": []
        }
        
        # التحقق من وجود نماذج للفحص
        if not hasattr(self, "target_info") or "forms" not in self.target_info or not self.target_info["forms"]:
            return xss_results
        
        # حقن XSS للاختبار
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg/onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "\'\"><script>alert('XSS')</script>",
            "\"'><img src=x onerror=alert('XSS')>"
        ]
        
        # فحص كل نموذج
        for form in self.target_info["forms"]:
            for payload in xss_payloads:
                # إنشاء بيانات النموذج للاختبار
                form_data = {}
                for input_field in form["inputs"]:
                    if input_field["type"] in ["text", "search", "url", "tel", "email", "password"]:
                        form_data[input_field["name"]] = payload
                    else:
                        form_data[input_field["name"]] = "test"
                
                try:
                    headers = {"User-Agent": get_random_user_agent()}
                    
                    if form["method"] == "GET":
                        response = requests.get(
                            form["action"],
                            params=form_data,
                            headers=headers,
                            timeout=self.timeout,
                            allow_redirects=True
                        )
                    else:  # POST
                        response = requests.post(
                            form["action"],
                            data=form_data,
                            headers=headers,
                            timeout=self.timeout,
                            allow_redirects=True
                        )
                    
                    # التحقق من وجود الثغرة في الاستجابة
                    if payload in response.text:
                        xss_results["vulnerabilities"].append({
                            "form": form["action"],
                            "method": form["method"],
                            "payload": payload,
                            "status_code": response.status_code
                        })
                        break  # الانتقال إلى النموذج التالي بعد العثور على ثغرة
                
                except Exception as e:
                    if self.logger:
                        self.logger.error(f"[!] خطأ في فحص XSS للنموذج {form['action']}: {str(e)}")
        
        # تحديث مستوى الخطورة بناءً على النتائج
        if xss_results["vulnerabilities"]:
            xss_results["status"] = "Vulnerable"
        else:
            xss_results["status"] = "Not Vulnerable"
            xss_results["severity"] = "Info"
        
        return xss_results
    
    def _check_sqli(self):
        """فحص ثغرات SQL Injection"""
        sqli_results = {
            "name": "SQL Injection",
            "description": "ثغرة تسمح للمهاجمين بحقن استعلامات SQL ضارة في التطبيق",
            "severity": "Critical",
            "vulnerabilities": []
        }
        
        # التحقق من وجود نماذج للفحص
        if not hasattr(self, "target_info") or "forms" not in self.target_info or not self.target_info["forms"]:
            return sqli_results
        
        # حقن SQL للاختبار
        sqli_payloads = [
            "' OR '1'='1",
            "' OR 1=1 --",
            "\" OR 1=1 --",
            "' OR '1'='1' --",
            "admin' --",
            "1' OR '1' = '1",
            "1 OR 1=1"
        ]
        
        # أنماط الخطأ التي تشير إلى وجود ثغرة SQL Injection
        error_patterns = [
            "SQL syntax",
            "mysql_fetch",
            "ORA-",
            "MySQL server",
            "PostgreSQL",
            "SQLite",
            "SQL Server",
            "syntax error",
            "unclosed quotation mark",
            "unterminated string"
        ]
        
        # فحص كل نموذج
        for form in self.target_info["forms"]:
            for payload in sqli_payloads:
                # إنشاء بيانات النموذج للاختبار
                form_data = {}
                for input_field in form["inputs"]:
                    if input_field["type"] in ["text", "search", "url", "tel", "email", "password", "hidden"]:
                        form_data[input_field["name"]] = payload
                    else:
                        form_data[input_field["name"]] = "test"
                
                try:
                    headers = {"User-Agent": get_random_user_agent()}
                    
                    if form["method"] == "GET":
                        response = requests.get(
                            form["action"],
                            params=form_data,
                            headers=headers,
                            timeout=self.timeout,
                            allow_redirects=True
                        )
                    else:  # POST
                        response = requests.post(
                            form["action"],
                            data=form_data,
                            headers=headers,
                            timeout=self.timeout,
                            allow_redirects=True
                        )
                    
                    # التحقق من وجود أنماط الخطأ في الاستجابة
                    for pattern in error_patterns:
                        if pattern.lower() in response.text.lower():
                            sqli_results["vulnerabilities"].append({
                                "form": form["action"],
                                "method": form["method"],
                                "payload": payload,
                                "error_pattern": pattern,
                                "status_code": response.status_code
                            })
                            break  # الانتقال إلى النموذج التالي بعد العثور على ثغرة
                    
                    # التحقق من تغير سلوك التطبيق (مثل تسجيل الدخول بنجاح)
                    if "admin" in response.text.lower() or "dashboard" in response.text.lower() or "logout" in response.text.lower():
                        sqli_results["vulnerabilities"].append({
                            "form": form["action"],
                            "method": form["method"],
                            "payload": payload,
                            "behavior_change": "Possible authentication bypass",
                            "status_code": response.status_code
                        })
                        break  # الانتقال إلى النموذج التالي بعد العثور على ثغرة
                
                except Exception as e:
                    if self.logger:
                        self.logger.error(f"[!] خطأ في فحص SQL Injection للنموذج {form['action']}: {str(e)}")
        
        # تحديث مستوى الخطورة بناءً على النتائج
        if sqli_results["vulnerabilities"]:
            sqli_results["status"] = "Vulnerable"
        else:
            sqli_results["status"] = "Not Vulnerable"
            sqli_results["severity"] = "Info"
        
        return sqli_results
    
    def _check_lfi(self):
        """فحص ثغرات Local File Inclusion (LFI)"""
        lfi_results = {
            "name": "Local File Inclusion (LFI)",
            "description": "ثغرة تسمح للمهاجمين بالوصول إلى الملفات المحلية على الخادم",
            "severity": "High",
            "vulnerabilities": []
        }
        
        # مسارات LFI للاختبار
        lfi_paths = [
            "../../../etc/passwd",
            "../../../etc/hosts",
            "../../../windows/win.ini",
            "../../../boot.ini",
            "../../../../../../etc/passwd",
            "../../../../../../etc/hosts",
            "../../../../../../windows/win.ini",
            "../../../../../../boot.ini"
        ]
        
        # أنماط للتحقق من نجاح الاستغلال
        lfi_patterns = {
            "../../../etc/passwd": ["root:", "bin:", "daemon:"],
            "../../../etc/hosts": ["localhost", "127.0.0.1"],
            "../../../windows/win.ini": ["for 16-bit app support"],
            "../../../boot.ini": ["[boot loader]", "[operating systems]"]
        }
        
        # استخراج المعلمات من URL الهدف
        parsed_url = urlparse(self.target)
        query_params = parsed_url.query.split("&")
        
        # فحص كل معلمة في URL
        for param in query_params:
            if "=" in param:
                param_name = param.split("=")[0]
                
                for lfi_path in lfi_paths:
                    # إنشاء URL للاختبار
                    test_url = self.target.replace(f"{param_name}=", f"{param_name}={lfi_path}")
                    
                    try:
                        headers = {"User-Agent": get_random_user_agent()}
                        response = requests.get(test_url, headers=headers, timeout=self.timeout)
                        
                        # التحقق من وجود أنماط LFI في الاستجابة
                        for path, patterns in lfi_patterns.items():
                            if any(pattern in response.text for pattern in patterns):
                                lfi_results["vulnerabilities"].append({
                                    "url": test_url,
                                    "parameter": param_name,
                                    "payload": lfi_path,
                                    "status_code": response.status_code
                                })
                                break  # الانتقال إلى المعلمة التالية بعد العثور على ثغرة
                    
                    except Exception as e:
                        if self.logger:
                            self.logger.error(f"[!] خطأ في فحص LFI للمعلمة {param_name}: {str(e)}")
        
        # فحص المسارات المحتملة في URL
        url_path = parsed_url.path
        if "/" in url_path and "." in url_path:
            path_parts = url_path.split("/")
            for i in range(len(path_parts)):
                if "." in path_parts[i]:
                    for lfi_path in lfi_paths:
                        # إنشاء URL للاختبار
                        new_path_parts = path_parts.copy()
                        new_path_parts[i] = lfi_path
                        new_url_path = "/".join(new_path_parts)
                        test_url = self.target.replace(url_path, new_url_path)
                        
                        try:
                            headers = {"User-Agent": get_random_user_agent()}
                            response = requests.get(test_url, headers=headers, timeout=self.timeout)
                            
                            # التحقق من وجود أنماط LFI في الاستجابة
                            for path, patterns in lfi_patterns.items():
                                if any(pattern in response.text for pattern in patterns):
                                    lfi_results["vulnerabilities"].append({
                                        "url": test_url,
                                        "parameter": "path",
                                        "payload": lfi_path,
                                        "status_code": response.status_code
                                    })
                                    break  # الانتقال إلى المسار التالي بعد العثور على ثغرة
                        
                        except Exception as e:
                            if self.logger:
                                self.logger.error(f"[!] خطأ في فحص LFI للمسار {new_url_path}: {str(e)}")
        
        # تحديث مستوى الخطورة بناءً على النتائج
        if lfi_results["vulnerabilities"]:
            lfi_results["status"] = "Vulnerable"
        else:
            lfi_results["status"] = "Not Vulnerable"
            lfi_results["severity"] = "Info"
        
        return lfi_results
    
    def _check_rfi(self):
        """فحص ثغرات Remote File Inclusion (RFI)"""
        rfi_results = {
            "name": "Remote File Inclusion (RFI)",
            "description": "ثغرة تسمح للمهاجمين بتضمين ملفات بعيدة في التطبيق",
            "severity": "Critical",
            "vulnerabilities": []
        }
        
        # مسارات RFI للاختبار (استخدام مواقع آمنة للاختبار)
        rfi_paths = [
            "http://example.com/",
            "https://www.google.com/",
            "https://www.bing.com/"
        ]
        
        # استخراج المعلمات من URL الهدف
        parsed_url = urlparse(self.target)
        query_params = parsed_url.query.split("&")
        
        # فحص كل معلمة في URL
        for param in query_params:
            if "=" in param:
                param_name = param.split("=")[0]
                
                for rfi_path in rfi_paths:
                    # إنشاء URL للاختبار
                    test_url = self.target.replace(f"{param_name}=", f"{param_name}={rfi_path}")
                    
                    try:
                        headers = {"User-Agent": get_random_user_agent()}
                        response = requests.get(test_url, headers=headers, timeout=self.timeout)
                        
                        # التحقق من وجود محتوى الموقع البعيد في الاستجابة
                        if "Example Domain" in response.text or "Google" in response.text or "Bing" in response.text:
                            rfi_results["vulnerabilities"].append({
                                "url": test_url,
                                "parameter": param_name,
                                "payload": rfi_path,
                                "status_code": response.status_code
                            })
                            break  # الانتقال إلى المعلمة التالية بعد العثور على ثغرة
                    
                    except Exception as e:
                        if self.logger:
                            self.logger.error(f"[!] خطأ في فحص RFI للمعلمة {param_name}: {str(e)}")
        
        # تحديث مستوى الخطورة بناءً على النتائج
        if rfi_results["vulnerabilities"]:
            rfi_results["status"] = "Vulnerable"
        else:
            rfi_results["status"] = "Not Vulnerable"
            rfi_results["severity"] = "Info"
        
        return rfi_results
    
    def _check_open_redirect(self):
        """فحص ثغرات Open Redirect"""
        redirect_results = {
            "name": "Open Redirect",
            "description": "ثغرة تسمح للمهاجمين بإعادة توجيه المستخدمين إلى مواقع ضارة",
            "severity": "Medium",
            "vulnerabilities": []
        }
        
        # مواقع للاختبار (استخدام مواقع آمنة)
        redirect_urls = [
            "https://example.com",
            "https://google.com",
            "//example.com",
            "//google.com"
        ]
        
        # معلمات إعادة التوجيه الشائعة
        redirect_params = ["redirect", "url", "next", "return", "returnUrl", "returnTo", "goto", "continue", "dest", "destination"]
        
        # استخراج المعلمات من URL الهدف
        parsed_url = urlparse(self.target)
        query_params = parsed_url.query.split("&")
        
        # فحص المعلمات الموجودة في URL
        for param in query_params:
            if "=" in param:
                param_name = param.split("=")[0]
                
                if param_name.lower() in redirect_params or "redirect" in param_name.lower() or "url" in param_name.lower():
                    for redirect_url in redirect_urls:
                        # إنشاء URL للاختبار
                        test_url = self.target.replace(f"{param_name}=", f"{param_name}={redirect_url}")
                        
                        try:
                            headers = {"User-Agent": get_random_user_agent()}
                            response = requests.get(test_url, headers=headers, timeout=self.timeout, allow_redirects=False)
                            
                            # التحقق من وجود إعادة توجيه
                            if response.status_code in [301, 302, 303, 307, 308]:
                                location = response.headers.get("Location", "")
                                if redirect_url in location or redirect_url.replace("https://", "") in location:
                                    redirect_results["vulnerabilities"].append({
                                        "url": test_url,
                                        "parameter": param_name,
                                        "payload": redirect_url,
                                        "status_code": response.status_code,
                                        "location": location
                                    })
                                    break  # الانتقال إلى المعلمة التالية بعد العثور على ثغرة
                        
                        except Exception as e:
                            if self.logger:
                                self.logger.error(f"[!] خطأ في فحص Open Redirect للمعلمة {param_name}: {str(e)}")
        
        # فحص معلمات إعادة التوجيه الشائعة إذا لم تكن موجودة في URL
        for param_name in redirect_params:
            if not any(param.startswith(f"{param_name}=") for param in query_params):
                for redirect_url in redirect_urls:
                    # إنشاء URL للاختبار
                    separator = "&" if parsed_url.query else "?"
                    test_url = f"{self.target}{separator}{param_name}={redirect_url}"
                    
                    try:
                        headers = {"User-Agent": get_random_user_agent()}
                        response = requests.get(test_url, headers=headers, timeout=self.timeout, allow_redirects=False)
                        
                        # التحقق من وجود إعادة توجيه
                        if response.status_code in [301, 302, 303, 307, 308]:
                            location = response.headers.get("Location", "")
                            if redirect_url in location or redirect_url.replace("https://", "") in location:
                                redirect_results["vulnerabilities"].append({
                                    "url": test_url,
                                    "parameter": param_name,
                                    "payload": redirect_url,
                                    "status_code": response.status_code,
                                    "location": location
                                })
                                break  # الانتقال إلى المعلمة التالية بعد العثور على ثغرة
                    
                    except Exception as e:
                        if self.logger:
                            self.logger.error(f"[!] خطأ في فحص Open Redirect للمعلمة {param_name}: {str(e)}")
        
        # تحديث مستوى الخطورة بناءً على النتائج
        if redirect_results["vulnerabilities"]:
            redirect_results["status"] = "Vulnerable"
        else:
            redirect_results["status"] = "Not Vulnerable"
            redirect_results["severity"] = "Info"
        
        return redirect_results
    
    def _check_csrf(self):
        """فحص ثغرات Cross-Site Request Forgery (CSRF)"""
        csrf_results = {
            "name": "Cross-Site Request Forgery (CSRF)",
            "description": "ثغرة تسمح للمهاجمين بتنفيذ إجراءات غير مصرح بها نيابة عن المستخدم",
            "severity": "Medium",
            "vulnerabilities": []
        }
        
        # التحقق من وجود نماذج للفحص
        if not hasattr(self, "target_info") or "forms" not in self.target_info or not self.target_info["forms"]:
            return csrf_results
        
        # فحص كل نموذج
        for form in self.target_info["forms"]:
            if form["method"] == "POST":  # التركيز على نماذج POST
                # البحث عن رموز CSRF في النموذج
                csrf_tokens = False
                for input_field in form["inputs"]:
                    input_name = input_field["name"].lower()
                    if "csrf" in input_name or "token" in input_name or "nonce" in input_name:
                        csrf_tokens = True
                        break
                
                if not csrf_tokens:
                    # التحقق من وجود رموز CSRF في ترويسات HTTP
                    try:
                        headers = {"User-Agent": get_random_user_agent()}
                        response = requests.get(form["action"], headers=headers, timeout=self.timeout)
                        
                        if not any(header.lower() in ["x-csrf-token", "x-xsrf-token"] for header in response.headers):
                            csrf_results["vulnerabilities"].append({
                                "form": form["action"],
                                "method": form["method"],
                                "issue": "No CSRF token found in form or headers"
                            })
                    
                    except Exception as e:
                        if self.logger:
                            self.logger.error(f"[!] خطأ في فحص CSRF للنموذج {form['action']}: {str(e)}")
        
        # تحديث مستوى الخطورة بناءً على النتائج
        if csrf_results["vulnerabilities"]:
            csrf_results["status"] = "Potentially Vulnerable"
        else:
            csrf_results["status"] = "Not Vulnerable"
            csrf_results["severity"] = "Info"
        
        return csrf_results
    
    def _check_clickjacking(self):
        """فحص ثغرات Clickjacking"""
        clickjacking_results = {
            "name": "Clickjacking",
            "description": "ثغرة تسمح للمهاجمين بخداع المستخدمين للنقر على عناصر مخفية",
            "severity": "Medium",
            "vulnerabilities": []
        }
        
        try:
            headers = {"User-Agent": get_random_user_agent()}
            response = requests.get(self.target, headers=headers, timeout=self.timeout)
            
            # التحقق من وجود ترويسة X-Frame-Options
            x_frame_options = response.headers.get("X-Frame-Options", "").upper()
            
            # التحقق من وجود سياسة Content-Security-Policy مع تقييد frame-ancestors
            csp = response.headers.get("Content-Security-Policy", "")
            frame_ancestors_csp = False
            if "frame-ancestors" in csp:
                frame_ancestors_csp = True
            
            if not x_frame_options and not frame_ancestors_csp:
                clickjacking_results["vulnerabilities"].append({
                    "url": self.target,
                    "issue": "Missing X-Frame-Options and frame-ancestors CSP directive"
                })
            elif x_frame_options and x_frame_options not in ["DENY", "SAMEORIGIN"]:
                clickjacking_results["vulnerabilities"].append({
                    "url": self.target,
                    "issue": f"Weak X-Frame-Options: {x_frame_options}"
                })
        
        except Exception as e:
            if self.logger:
                self.logger.error(f"[!] خطأ في فحص Clickjacking: {str(e)}")
        
        # تحديث مستوى الخطورة بناءً على النتائج
        if clickjacking_results["vulnerabilities"]:
            clickjacking_results["status"] = "Vulnerable"
        else:
            clickjacking_results["status"] = "Not Vulnerable"
            clickjacking_results["severity"] = "Info"
        
        return clickjacking_results
    
    def _check_cors(self):
        """فحص ثغرات Cross-Origin Resource Sharing (CORS)"""
        cors_results = {
            "name": "Cross-Origin Resource Sharing (CORS)",
            "description": "ثغرة تسمح للمواقع الخارجية بالوصول إلى موارد الموقع",
            "severity": "Medium",
            "vulnerabilities": []
        }
        
        # مواقع للاختبار
        origins = [
            "https://evil.com",
            "http://attacker.com",
            "null"
        ]
        
        for origin in origins:
            try:
                headers = {
                    "User-Agent": get_random_user_agent(),
                    "Origin": origin
                }
                response = requests.get(self.target, headers=headers, timeout=self.timeout)
                
                # التحقق من ترويسة Access-Control-Allow-Origin
                acao = response.headers.get("Access-Control-Allow-Origin", "")
                acac = response.headers.get("Access-Control-Allow-Credentials", "").lower() == "true"
                
                if acao == "*" or acao == origin:
                    issue = f"Permissive CORS: Access-Control-Allow-Origin: {acao}"
                    
                    if acac:
                        issue += " with Access-Control-Allow-Credentials: true"
                    
                    cors_results["vulnerabilities"].append({
                        "url": self.target,
                        "origin": origin,
                        "issue": issue,
                        "response_headers": {
                            "Access-Control-Allow-Origin": acao,
                            "Access-Control-Allow-Credentials": acac
                        }
                    })
            
            except Exception as e:
                if self.logger:
                    self.logger.error(f"[!] خطأ في فحص CORS مع Origin={origin}: {str(e)}")
        
        # تحديث مستوى الخطورة بناءً على النتائج
        if cors_results["vulnerabilities"]:
            cors_results["status"] = "Vulnerable"
        else:
            cors_results["status"] = "Not Vulnerable"
            cors_results["severity"] = "Info"
        
        return cors_results
    
    def _check_ssl_tls(self):
        """فحص مشكلات SSL/TLS"""
        ssl_results = {
            "name": "SSL/TLS Configuration",
            "description": "فحص تكوين SSL/TLS للكشف عن المشكلات الأمنية",
            "severity": "Medium",
            "vulnerabilities": []
        }
        
        # التحقق من استخدام HTTPS
        if not self.target.startswith("https://"):
            ssl_results["vulnerabilities"].append({
                "url": self.target,
                "issue": "Not using HTTPS"
            })
            ssl_results["status"] = "Vulnerable"
            ssl_results["severity"] = "High"
            return ssl_results
        
        try:
            headers = {"User-Agent": get_random_user_agent()}
            response = requests.get(self.target, headers=headers, timeout=self.timeout)
            
            # التحقق من ترويسة Strict-Transport-Security
            hsts = response.headers.get("Strict-Transport-Security", "")
            if not hsts:
                ssl_results["vulnerabilities"].append({
                    "url": self.target,
                    "issue": "Missing HTTP Strict Transport Security (HSTS) header"
                })
            elif "max-age=" in hsts:
                max_age = re.search(r"max-age=([0-9]+)", hsts)
                if max_age and int(max_age.group(1)) < 31536000:  # أقل من سنة
                    ssl_results["vulnerabilities"].append({
                        "url": self.target,
                        "issue": f"HSTS max-age too short: {max_age.group(1)} seconds (recommended: 31536000)"
                    })
            
            # التحقق من إعادة التوجيه من HTTP إلى HTTPS
            http_url = self.target.replace("https://", "http://")
            try:
                http_response = requests.get(http_url, headers=headers, timeout=self.timeout, allow_redirects=False)
                
                if http_response.status_code not in [301, 302, 307, 308]:
                    ssl_results["vulnerabilities"].append({
                        "url": http_url,
                        "issue": "HTTP to HTTPS redirect not implemented"
                    })
                elif "https://" not in http_response.headers.get("Location", ""):
                    ssl_results["vulnerabilities"].append({
                        "url": http_url,
                        "issue": "HTTP to HTTPS redirect not properly configured"
                    })
            except Exception:
                pass  # تجاهل الأخطاء في فحص إعادة التوجيه
        
        except Exception as e:
            if self.logger:
                self.logger.error(f"[!] خطأ في فحص SSL/TLS: {str(e)}")
        
        # تحديث مستوى الخطورة بناءً على النتائج
        if ssl_results["vulnerabilities"]:
            ssl_results["status"] = "Vulnerable"
        else:
            ssl_results["status"] = "Not Vulnerable"
            ssl_results["severity"] = "Info"
        
        return ssl_results
    
    def _check_common_cve(self):
        """فحص الثغرات المعروفة (CVE) الشائعة"""
        cve_results = {
            "name": "Common Vulnerabilities and Exposures (CVE)",
            "description": "فحص الثغرات المعروفة والشائعة",
            "severity": "High",
            "vulnerabilities": []
        }
        
        # التحقق من وجود معلومات الهدف
        if not hasattr(self, "target_info") or "technologies" not in self.target_info:
            return cve_results
        
        # قائمة الثغرات الشائعة حسب التقنية
        cve_checks = {
            "WordPress": [
                {
                    "path": "/wp-content/plugins/wp-file-manager/readme.txt",
                    "pattern": "Version: 6",
                    "cve": "CVE-2020-25213",
                    "description": "WordPress File Manager < 6.9 - Arbitrary File Upload"
                },
                {
                    "path": "/wp-json/wp/v2/users/",
                    "pattern": "slug",
                    "cve": "CVE-2019-11043",
                    "description": "WordPress User Enumeration via REST API"
                }
            ],
            "Joomla": [
                {
                    "path": "/administrator/manifests/files/joomla.xml",
                    "pattern": "<version>3.7.0</version>",
                    "cve": "CVE-2017-8917",
                    "description": "Joomla! 3.7.0 - SQL Injection"
                }
            ],
            "Drupal": [
                {
                    "path": "/CHANGELOG.txt",
                    "pattern": "Drupal 7",
                    "cve": "CVE-2018-7600",
                    "description": "Drupal < 7.58 / < 8.3.9 / < 8.4.6 / < 8.5.1 - 'Drupalgeddon2' Remote Code Execution"
                }
            ],
            "Apache": [
                {
                    "path": "/server-status",
                    "pattern": "Apache Server Status",
                    "cve": "Information Disclosure",
                    "description": "Apache Server Status Exposed"
                }
            ],
            "PHP": [
                {
                    "path": "/phpinfo.php",
                    "pattern": "<title>phpinfo()</title>",
                    "cve": "Information Disclosure",
                    "description": "PHP Information Disclosure"
                }
            ]
        }
        
        # فحص الثغرات حسب التقنيات المكتشفة
        for tech in self.target_info["technologies"]:
            if tech in cve_checks:
                for check in cve_checks[tech]:
                    try:
                        url = urljoin(self.target, check["path"])
                        headers = {"User-Agent": get_random_user_agent()}
                        response = requests.get(url, headers=headers, timeout=self.timeout)
                        
                        if response.status_code == 200 and check["pattern"] in response.text:
                            cve_results["vulnerabilities"].append({
                                "url": url,
                                "technology": tech,
                                "cve": check["cve"],
                                "description": check["description"],
                                "status_code": response.status_code
                            })
                    
                    except Exception as e:
                        if self.logger:
                            self.logger.error(f"[!] خطأ في فحص CVE {check['cve']}: {str(e)}")
        
        # فحص إضافي للخوادم
        if "server" in self.target_info and self.target_info["server"] != "Unknown":
            server = self.target_info["server"]
            
            # فحص Apache
            if "Apache" in server and re.search(r"Apache/2\.4\.(\d+)", server):
                version = re.search(r"Apache/2\.4\.(\d+)", server).group(1)
                if int(version) < 50:  # Apache < 2.4.50
                    cve_results["vulnerabilities"].append({
                        "url": self.target,
                        "technology": "Apache",
                        "cve": "CVE-2021-41773/CVE-2021-42013",
                        "description": f"Apache 2.4.{version} - Path Traversal and Remote Code Execution",
                        "version": f"2.4.{version}"
                    })
            
            # فحص Nginx
            elif "nginx" in server.lower() and re.search(r"nginx/(\d+\.\d+\.\d+)", server, re.I):
                version = re.search(r"nginx/(\d+\.\d+\.\d+)", server, re.I).group(1)
                if version.startswith("1.20.0") or version.startswith("1.21.0"):
                    cve_results["vulnerabilities"].append({
                        "url": self.target,
                        "technology": "Nginx",
                        "cve": "CVE-2021-23017",
                        "description": f"Nginx {version} - Buffer Overflow",
                        "version": version
                    })
        
        # تحديث مستوى الخطورة بناءً على النتائج
        if cve_results["vulnerabilities"]:
            cve_results["status"] = "Vulnerable"
        else:
            cve_results["status"] = "Not Vulnerable"
            cve_results["severity"] = "Info"
        
        return cve_results
    
    def _assess_risk(self):
        """تقييم مستوى الخطورة الإجمالي"""
        risk_assessment = {
            "risk_level": "Low",
            "summary": {
                "critical": 0,
                "high": 0,
                "medium": 0,
                "low": 0,
                "info": 0
            },
            "vulnerable_components": []
        }
        
        # حساب عدد الثغرات حسب مستوى الخطورة
        for vuln_type, vuln_result in self.results.items():
            if isinstance(vuln_result, dict) and "vulnerabilities" in vuln_result and "severity" in vuln_result:
                if vuln_result["vulnerabilities"]:
                    severity = vuln_result["severity"]
                    risk_assessment["summary"][severity.lower()] += len(vuln_result["vulnerabilities"])
                    
                    risk_assessment["vulnerable_components"].append({
                        "name": vuln_result["name"],
                        "severity": severity,
                        "count": len(vuln_result["vulnerabilities"])
                    })
        
        # تحديد مستوى الخطورة الإجمالي
        if risk_assessment["summary"]["critical"] > 0:
            risk_assessment["risk_level"] = "Critical"
        elif risk_assessment["summary"]["high"] > 0:
            risk_assessment["risk_level"] = "High"
        elif risk_assessment["summary"]["medium"] > 0:
            risk_assessment["risk_level"] = "Medium"
        elif risk_assessment["summary"]["low"] > 0:
            risk_assessment["risk_level"] = "Low"
        else:
            risk_assessment["risk_level"] = "Info"
        
        return risk_assessment